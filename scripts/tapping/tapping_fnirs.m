function  tapping_fnirs(tutorial_dir, reports_dir)
% tapping_fnirs: Script to PERFORM wMEM on the tapping dataset
% Dataset: https://osf.io/md54y/?view_only=0d8ad17d1e1449b5ad36864eeb3424ed 
% CORRESPONDING ONLINE TUTORIALS:
%     https://neuroimage.usc.edu/brainstorm/Tutorials/NIRSTORM
%
% INPUTS: 
%    - tutorial_dir: Directory where the sample_nirstorm.zip file has been downloaded
%    - reports_dir  : Directory where to save the execution report (instead of displaying it)
% Example: 
% in = '/Users/edelaire1/Documents/Project/wMEM-fnirs/data/nirstorm_tutorial_2024'
% tapping_fnirs(in)
% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
% 
% Copyright (c) University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
% 
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Author: Edouard Delaire, 2024

% ===== FILES TO IMPORT =====
% Output folder for reports
if (nargin < 2) || isempty(reports_dir) || ~isdir(reports_dir)
    reports_dir = [];
end

% You have to specify the folder in which the tutorial dataset is unzipped
if (nargin == 0) || isempty(tutorial_dir) || ~file_exist(tutorial_dir)
    error('The first argument must be the full path to the tutorial dataset folder.');
end

% Protocol information options: 
ProtocolName    = 'wMEM-nirs';
SubjectName     = 'sub-01';
recompute_fluence = 0;

% Start brainstorm without the GUI
if ~brainstorm('status')
    brainstorm nogui
end

% ===== CREATE PROTOCOL =====
iProtocol = bst_get('Protocol', ProtocolName);
if isempty(iProtocol)
    % Create new protocol
    gui_brainstorm('CreateProtocol', ProtocolName, 0, 0);
else
    % Load protocol
    gui_brainstorm('SetCurrentProtocol', iProtocol);
end



% Start a new report
bst_report('Start');

FidFile                     = fullfile(tutorial_dir, SubjectName, 'anat','T1w.json');
FSPath                      = fullfile(tutorial_dir, 'derivatives', 'FreeSurfer/',SubjectName);
TissueSegmentationFile      = fullfile(tutorial_dir, 'derivatives', 'segmentation',SubjectName,'segmentation_5tissues.nii');
scoutPath                   = fullfile(tutorial_dir, 'derivatives', 'segmentation',SubjectName,'scout_hand.annot');
RawFile                     = fullfile(tutorial_dir, SubjectName, 'nirs',sprintf('%s_task-tapping_run-01.snirf',SubjectName));

% Check if the folder contains the required files
if ~file_exist(RawFile)
    error(['The folder ' tutorial_dir ' does not contain the folder from the file nirstorm_tutorial_2024.zip.']);
end


%% Part 1. Importing subject anatomical data
json = bst_jsondecode(FidFile);
sFid = process_import_bids('GetFiducials',json, 'voxel');

bst_process('CallProcess', 'process_import_anatomy', [], [], ...
    'subjectname', SubjectName, ...
    'mrifile',     {FSPath, 'FreeSurfer+Thick'}, ...
    'nvertices',   15000, ...
    'nas',         sFid.NAS, ...
    'lpa',         sFid.LPA, ...
    'rpa',         sFid.RPA, ...
    'ac',          sFid.AC, ...
    'pc',          sFid.PC, ...
    'ih',          sFid.IH);

[sSubject, iSubject]  = bst_get('Subject', SubjectName);

% % Import tissue segmentation
import_mri(iSubject, TissueSegmentationFile, '', 0, 0, 'segmentation_5tissues');
% 
% % Remesh skin to 10 000 vertices, iso-mesh
tess_remesh(sSubject.Surface(sSubject.iScalp).FileName ,10000 )
% 
% % Choose mid-surface as default cortical surface
iCortex = find(contains({sSubject.Surface.FileName},'tess_cortex_mid_low.mat'));
db_surface_default(iSubject, 'Cortex',iCortex);
panel_protocols('RepaintTree');
% 
% % Import hand-know region
import_label(sSubject.Surface(iCortex).FileName, scoutPath,0);
% 
% % Compute voronoi-interpolation
bst_process('CallProcess', 'process_nst_compute_voronoi', [], [], ...
    'subjectname',  SubjectName, ...
    'do_grey_mask', 1);



%% Part 2. Import functional data


sFile = bst_process('CallProcess', 'process_import_data_raw', [], [], ...
                                    'subjectname',    SubjectName, ...
                                    'datafile',       {RawFile, 'NIRS-SNIRF'}, ...
                                    'channelreplace', 1, ...
                                    'channelalign',   1, ...
                                    'evtmode',        'value');


% Import head points 
% Note: already done since headpoints are included in the snirf file
% bst_process('CallProcess', 'process_headpoints_add', sFile, [], ...
%             'channelfile', {HeadpointsPath, 'ASCII_NXYZ'}, ...
%             'fixunits',    0.1, ...
%             'vox2ras',     0); % we are using fiducials define in headpoints 

% Remove headpoints bellow nasion
% Note: already done since headpoints are included in the snirf file
% process_headpoints_remove('RemoveHeadpoints', sFile.ChannelFile, 0) 

% Refine registration
% Note: already done since headpoints are included in the snirf file
% bst_process('CallProcess', 'process_headpoints_refine', sFile, []);

% Process: Snapshot: Sensors/MRI registration
bst_process('CallProcess', 'process_snapshot', sFile, [], ...
    'target',   1, ...  % Sensors/MRI registration
    'modality', 7, ...  % NIRS
    'orient',   1, ...  % left
    'Comment',  'NIRS/MRI Registration');

% Process: Duplicate tapping events
sFile = bst_process('CallProcess', 'process_evt_merge', sFile, [], ...
    'evtnames', 'tapping', ...
    'newname',  'tapping/start', ...
    'delete',   0);

% Process: Convert to simple event
sFile = bst_process('CallProcess', 'process_evt_simple', sFile, [], ...
    'eventname',  'tapping/start', ...
    'method', 1);
sRaw = sFile;

%% Part 3. Preprocessing

% Process: Detect bad channels
sRaw = bst_process('CallProcess', 'process_nst_detect_bad', sRaw, [], ...
    'option_sci',                   0, ...
    'sci_threshold',                80, ...
    'power_threshold',              10, ...
    'option_coefficient_variation', 1, ...
    'coefficient_variation',        5, ...
    'option_remove_saturating',     0, ...
    'option_max_sat_prop',          10, ...
    'option_min_sat_prop',          10, ...
    'option_separation_filtering',  0, ...
    'option_separation',            [0, 5], ...
    'auxilary_signal',              3, ...  % Remove all
    'option_keep_unpaired',         0);

% Process: Conversion to dOD

sRawdOD = bst_process('CallProcess', 'process_nst_dOD', sRaw, [], ...
    'option_baseline_method', 1, ...  % mean
    'timewindow',             []);


% Process: Motion Corrected (TDDR)
sPreproc_tmp = bst_process('CallProcess', 'process_nst_motion_correction', sRawdOD, [], ...
                                            'method',            'tddr', ...  %  Temporal Derivative Distribution Repair
                                            'option_event_name', 'motion', ...
                                            'option_smoothing',  0.99);

sPreproc_tmp = bst_process('CallProcess', 'process_bandpass', sPreproc_tmp, [], ...
                                            'sensortypes', 'NIRS', ...
                                            'highpass',    0.002, ...
                                            'lowpass',     2, ...
                                            'tranband',    0.002, ...
                                            'attenuation', 'relax', ...     % 40dB (relaxed)
                                            'ver',         '2019', ...      % 2019
                                            'mirror',      0, ...
                                            'overwrite',   0);

sPreproc_tmp = bst_process('CallProcess', 'process_nst_remove_ssc', sPreproc_tmp, [], ...
                                            'SS_chan',                 'name', ...  % Based on Names
                                            'SS_chan_name',            'S1D17,S2D17', ...
                                            'separation_threshold_cm', 1.5);

sPreproc = bst_process('CallProcess', 'process_import_data_time', sPreproc_tmp, [], ...
                                            'subjectname',   SubjectName, ...
                                            'condition',     sprintf('%s_task-tapping_run-01_preproc',SubjectName), ...
                                            'timewindow',    [10 1100], ...
                                            'split',         0, ...
                                            'ignoreshort',   0, ...
                                            'usectfcomp',    0, ...
                                            'usessp',        0, ...
                                            'freq',          [], ...
                                            'baseline',      [], ...
                                            'blsensortypes', 'NIRS');

% Remove short-separation channels
tree_set_channelflag(sPreproc.FileName, 'AddBad', 'S1D17WL685, S1D17WL830, S2D17WL685, S2D17WL830, S3D17WL685, S3D17WL830');


%% Compute head model 
% Process: Compute fluence

FluenceDir  = fullfile(tutorial_dir, 'derivatives','Fluences', SubjectName);

if recompute_fluence


    bst_process('CallProcess', 'process_nst_cpt_fluences', sPreproc, [], ...
        'subjectname',  SubjectName, ...
        'fluencesCond', struct(...
             'surface',                   'montage', ...
             'ChannelFile',               sPreproc.ChannelFile    , ...
             'SubjectName',               SubjectName, ...
             'segmentation_label',        1, ...
             'wavelengths',               '685 ,830', ...
             'software',                  'mcxlab-cl', ...
             'mcxlab_gpuid',              1, ...
             'mcxlab_nphoton',            100, ...
             'outputdir',                 FluenceDir, ...
             'mcxlab_flag_thresh',        0, ...
             'mcxlab_overwrite_fluences', 0, ...
             'mcxlab_flag_autoOP',        1));
end

%     % Process: Compute head model from fluence
bst_process('CallProcess', 'process_nst_import_head_model', sPreproc, [], ...
    'data_source',               FluenceDir, ...
    'use_closest_wl',            0, ...
    'method',                    'geodesic_dist', ...  %  Geodesic (recommended)
    'smoothing_fwhm',            10, ...
    'use_all_pairs',             0, ...
    'normalize_fluence',         1, ...
    'force_median_spread',       0, ...
    'sensitivity_threshold_pct', 0);

% Side:quest: add wake event to sPreproc

sData = in_bst_data(sPreproc.FileName);
sData.Events(end+1) = sData.Events(end);
sData.Events(end).label = 'Wake';
sData.Events(end).times = [30; 1099];
sData.Events(end).epochs = [1];
sData.Events(end).color = [10. 0.5 0.7];
bst_save(file_fullpath(sPreproc.FileName), sData)

%% Part 4: Estimation of the HRF to tapping -> then localize

sAvg = low_pass_and_average(sPreproc);

%     % Process: Compute sources: BEst
mem_option = be_pipelineoptions([],  'cMEM', 'NIRS');
mem_option.optional = struct_copy_fields(mem_option.optional, ...
                     struct(...
                             'TimeSegment',     [-10, 30], ...
                             'BaselineType',    {{'within-data'}}, ...
                             'Baseline',        [], ...
                             'BaselineHistory', {{'within'}}, ...
                             'BaselineSegment', [-10, 0], ...
                             'groupAnalysis',   0, ...
                             'display',         0));
mem_option.model.depth_weigth_MEM = 0.3;
mem_option.model.depth_weigth_MNE = 0.3;


bst_process('CallProcess', 'process_nst_cmem', sAvg, [], ...
                            'mem', struct('MEMpaneloptions', mem_option), ...
                            'thresh_dis2cortex',       5, ...
                            'NoiseCov_recompute',      1, ...
                            'auto_neighborhood_order', 1, ...
                            'store_sparse_results',    0);

%% Part 5: Localize then estimate of the HRF to tapping

% open parpool
if isempty(gcp('nocreate'))
    parpool(8);
end


timewindow_full      = [30, 1099];
baselinewindow_full  = [250, 270];
localized_response   = [];

% Process: Source reconstruction - wMNE
sFileMne = bst_process('CallProcess', 'process_nst_wmne', sPreproc, [], ...
                                            'thresh_dis2cortex',  5, ...
                                            'depth_weightingMNE', 0.3, ...
                                            'TimeSegment',        timewindow_full, ...
                                            'NoiseCov_recompute', 1, ...
                                            'TimeSegmentNoise',   baselinewindow_full);
localized_response = [localized_response, sFileMne(contains({sFileMne.Comment}, {'HbO','HbR','HbT'}))];


% Process: Source reconstruction - wMEM [all scale] 
selected_scales = [1:10]; alpha_init = 7; neighborhood_order = 6; normalization = 'adaptive';
sFilewMEM = compute_wMEM(sPreproc, timewindow_full, baselinewindow_full, neighborhood_order, selected_scales, alpha_init, normalization);
localized_response = [localized_response, sFilewMEM(contains({sFilewMEM.Comment}, {'HbO','HbR','HbT'}))];
 
% Process: Source reconstruction - wMEM [selected scale]
selected_scales = [3:9]; alpha_init = 7; neighborhood_order = 6; normalization = 'adaptive';
sFilewMEM = compute_wMEM(sPreproc, timewindow_full, baselinewindow_full, neighborhood_order, selected_scales, alpha_init, normalization);
localized_response = [localized_response, sFilewMEM(contains({sFilewMEM.Comment}, {'HbO','HbR','HbT'}))];


% Estimate averaged response from the localization
low_pass_and_average(localized_response);

% close parpool
if isempty(gcp('nocreate'))
    delete(gcp);
end

%% Part 6: Estimate time-frequency representation 

if ~bst_plugin('Load', 'tfnirs')
    error('Unable to load TF-nirs');
end

% 6.1 - Estimate time-frequency on the cortex 
localized_response = localized_response(contains({localized_response.Comment}, {'HbO','HbR'}));
for iFile = 1:length(localized_response)

    % Process: Time-frequency: Morse Wavelet(source)
    bst_process('CallProcess', 'process_ft_wavelet_surface', localized_response(iFile), [], ...
                                            'timewindow',     timewindow_full, ...
                                            'sensortypes',    'NIRS', ...
                                            'scouts',         {'User scouts', {'hand'}}, ...
                                            'vanish_moments', 1.5, ...
                                            'order',          20, ...
                                            'nb_levels',      1024, ...
                                            'normalization',  1);

end

% 6.2 - Estimate time-frequency at the channel level
sPreprocHb = bst_process('CallProcess', 'process_nst_mbll_dOD', sPreproc, [], ...
                                            'option_age',         25, ...
                                            'option_pvf',         50, ...
                                            'option_do_plp_corr', 1, ...
                                            'option_dpf_method',  1);  % SCHOLKMANN2013

sChannels = in_bst_channel(sPreprocHb.ChannelFile);

new_cluster = repmat(struct('Sensors',{}, 'Label', '', 'Color', [1 0.843 0], 'Function','Mean'), 1, 2);

[iChannels, Comment] = channel_find(sChannels.Channel, {'HbO'});
new_cluster(1).Sensors = {sChannels.Channel(iChannels).Name};
new_cluster(1).Label = 'motor_HbO';
new_cluster(1).Color  = [1 0 0];
new_cluster(1).Function  = 'Mean';

[iChannels, Comment] = channel_find(sChannels.Channel, {'HbR'});
new_cluster(2).Sensors = {sChannels.Channel(iChannels).Name};
new_cluster(2).Label = 'motor_HbR';
new_cluster(2).Color  = [0, 0, 1];
new_cluster(2).Function  = 'Mean';

sChannels.Clusters = new_cluster;
bst_save(file_fullpath(sPreprocHb.ChannelFile), sChannels);


% Process: Time-frequency: Morse Wavelet
bst_process('CallProcess', 'process_ft_wavelet', sPreprocHb, [], ...
                                            'timewindow',     timewindow_full, ...
                                            'sensortypes',    'NIRS', ...
                                            'clusters',       {'motor_HbO', 'motor_HbR'}, ...
                                            'vanish_moments', 1.5, ...
                                            'order',          20, ...
                                            'nb_levels',      1024, ...
                                            'normalization',  1);

%% Save and display report
ReportFile = bst_report('Save', []);
if ~isempty(reports_dir) && ~isempty(ReportFile)
    bst_report('Export', ReportFile, reports_dir);
else
    bst_report('Open', ReportFile);
end

disp([10 'BST> Tappping estimation: Done.' 10]);

end

function sAvg = low_pass_and_average(sFile)

    sFile = bst_process('CallProcess', 'process_bandpass', sFile, [], ...
            'sensortypes', 'NIRS', ...
            'highpass',    0, ...
            'lowpass',     0.1, ...
            'tranband',    0.005, ...
            'attenuation', 'relax', ...     % 40dB (relaxed)
            'ver',         '2019', ...      % 2019
            'mirror',      0, ...
            'overwrite',   0);

    sAvg = bst_process('CallProcess', 'process_windows_average_time', sFile, [], ...
                    'Eventname',      'tapping', ...
                    'timewindow',     [-10, 30], ...
                    'remove_DC',      1, ...
                    'baselinewindow', [-10, 0], ...
                    'overwrite',      0, ...
                    'source_abs',     0);

end

function sFilesMEM = compute_wMEM(sImput, timewindow_full, baselinewindow_full, neighborhood_order, selected_scales, alpha_init, normalization)

    mem_option = be_pipelineoptions([], 'wMEM','NIRS');
    mem_option.optional = struct_copy_fields(mem_option.optional, ...
                                        struct(...
                                        'TimeSegment',    timewindow_full, ...
                                        'BaselineType',    {{'within-data'}}, ...
                                        'BaselineHistory', {{'within'}}, ...
                                        "baseline_shuffle", 0, ...
                                        "BaselineSegment", baselinewindow_full , ...
                                        'display',         1));
    
    mem_option.clustering =  struct_copy_fields(mem_option.clustering, ...
                                         struct('neighborhood_order', neighborhood_order));
    
    mem_option.wavelet.selected_scales  = selected_scales;
    mem_option.model.alpha_method       = alpha_init;
    mem_option.optional.normalization   = normalization;
    mem_option.solver.parallel_matlab   = 1;
    
    sFilesMEM = bst_process('CallProcess', 'process_nst_cmem', sImput, [], ...
        'mem', struct('MEMpaneloptions', mem_option), ...
        'thresh_dis2cortex',       5, ...
        'NoiseCov_recompute',      1, ...
        'auto_neighborhood_order', 0, ...
        'store_sparse_results',    0);
    
    sFilesMEM =  bst_process('CallProcess', 'process_add_tag', sFilesMEM, [], ...
        'tag',            sprintf('| nbo = %d | alpha = %d | norm = %s',  neighborhood_order, alpha_init, normalization), ...
        'output',         'name'); 
end
